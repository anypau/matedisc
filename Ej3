#include <iostream>
#include <vector>
using namespace std;

// --------------------------------------------------------------
// Verifica si alpha es testor segun Prop. 1.3
// devuelve: -1 si es testor
// de lo contrario, devuelve el indice de la fila a de MB que provoca NO testor
// (la fila con el ultimo 1 mas a la izquierda, como pide el paper)
// --------------------------------------------------------------
int filaResponsable(const vector<vector<int>>& MB, const vector<int>& alpha)
{
    int mejorFila = -1;
    int mejorPos = 999999; // queremos el ultimo 1 mas a la izquierda (indice mas pequeno)

    int m = MB.size();
    int n = MB[0].size();

    for (int i = 0; i < m; i++) {

        bool cubre = false;

        for (int j = 0; j < n; j++) {
            if (alpha[j] == 1 && MB[i][j] == 1) {
                cubre = true;
                break;
            }
        }

        if (!cubre) {
            // α NO es testor → buscar el ultimo 1 mas a la izquierda en la fila i
            int ultimo1 = -1;
            for (int j = 0; j < n; j++)
                if (MB[i][j] == 1) {
                    ultimo1 = j;
                    break; // primer 1 = mas a la izquierda
                }

            if (ultimo1 < mejorPos) {
                mejorPos = ultimo1;
                mejorFila = i;
            }
        }
    }

    return mejorFila;
}

// --------------------------------------------------------------
// Proposición 1.4 – Salto desde TESTOR
// k = índice del último 1 en alpha
// --------------------------------------------------------------
vector<int> saltoTestor(const vector<int>& alpha)
{
    int n = alpha.size();
    vector<int> sig(n,0);

    int k = -1;
    for (int j = n-1; j >= 0; j--)
        if (alpha[j] == 1) {
            k = j;
            break;
        }

    if (k <= 0)
        return vector<int>(n,0); // fin del algoritmo

    // copiar alpha[0 .. k-2]
    for (int j = 0; j < k-1; j++)
        sig[j] = alpha[j];

    sig[k-1] = 1;
    // todo lo demas queda en 0
    return sig;
}

// --------------------------------------------------------------
// Proposición 1.5 – Salto desde NO testor
// usando la fila responsable "a" y su ultimo 1 mas a la izquierda
// --------------------------------------------------------------
vector<int> saltoNoTestor(const vector<vector<int>>& MB,
                           const vector<int>& alpha,
                           int fila)
{
    int n = alpha.size();
    vector<int> sig(n,0);

    // encontrar el ultimo 1 mas a la izquierda de la fila "fila"
    int k = -1;
    for (int j = 0; j < n; j++)
        if (MB[fila][j] == 1) {
            k = j;
            break;
        }

    // aplicar la definicion del PDF
    for (int j = 0; j < k; j++)
        sig[j] = alpha[j];

    sig[k] = 1;

    return sig;
}

// --------------------------------------------------------------
// Determinar si alpha es tipico (definicion directa)
// --------------------------------------------------------------
bool esTipico(const vector<vector<int>>& MB, const vector<int>& alpha)
{
    int n = alpha.size();

    for (int mask = 1; mask < (1<<n); mask++) {
        if (mask == (1<<n)-1) continue;

        vector<int> sub(n,0);
        for (int j = 0; j < n; j++)
            if (mask & (1<<j))
                sub[j] = alpha[j];

        if (filaResponsable(MB, sub) == -1)
            return false;
    }

    return true;
}

// --------------------------------------------------------------
// MAIN – Algoritmo BT EXACTO del PDF
// --------------------------------------------------------------
int main()
{
    int filas, columnas;
    cout << "Filas MB: ";
    cin >> filas;
    cout << "Columnas: ";
    cin >> columnas;

    vector<vector<int>> MB(filas, vector<int>(columnas));

    cout << "Ingrese MB:\n";
    for (int i = 0; i < filas; i++)
        for (int j = 0; j < columnas; j++)
            cin >> MB[i][j];

    vector<int> alpha(columnas,0);
    alpha[columnas-1] = 1; // empieza en (0,...,0,1)

    cout << "\nTestores tipicos:\n";

    while (true)
    {
        int f = filaResponsable(MB, alpha);

        if (f == -1) { 
            // ES TESTOR
            if (esTipico(MB, alpha)) {
                for (int b: alpha) cout << b;
                cout << endl;
            }

            alpha = saltoTestor(alpha); // Proposición 1.4
        }
        else { 
            // NO ES TESTOR
            alpha = saltoNoTestor(MB, alpha, f); // Proposición 1.5
        }

        // fin: alpha = 0000...0
        bool fin = true;
        for (int b: alpha)
            if (b == 1) fin = false;

        if (fin) break;
    }

    return 0;
}
