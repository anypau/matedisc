#include <iostream> 
#include <vector>
#include <fstream>
#include <sstream>
#include <string>
#include <algorithm>

using namespace std;

void escribirEnArchivo(const vector<vector<int>>& matriz, const string& nombre, const string& nombreArchivo) {
    ofstream archivo(nombreArchivo, ios::app); 
    if (archivo.is_open()) {
        archivo << "\n--- " << nombre << " ---\n";
        if (matriz.empty() || (matriz.size() > 0 && matriz[0].empty())) {
            archivo << "Matriz vacia.\n";
        } else {
            for (const auto& fila : matriz) {
                for (size_t i = 0; i < fila.size(); ++i) {
                    archivo << fila[i] << (i < fila.size() - 1 ? " " : ""); 
                }
                archivo << endl;
            }
        }
        archivo << "--------------------------\n";
        archivo.close();
    } else {
        cerr << "Error al escribir en " << nombreArchivo << endl;
    }
}

bool leerMatrizUnica(const string& nombreArchivo, vector<vector<int>>& matrizDestino) {
    ifstream archivo(nombreArchivo);
    if (!archivo.is_open()) {
        cerr << "Error: No se pudo abrir " << nombreArchivo << endl;
        return false;
    }

    string linea;
    while (getline(archivo, linea)) {
        if (linea.empty() || linea.find_first_not_of(" \t\n\r") == string::npos) continue;

        stringstream ss(linea);
        int valor;
        vector<int> fila;
        while (ss >> valor) {
            fila.push_back(valor);
        }
        if (!fila.empty()) {
            matrizDestino.push_back(fila);
        }
    }
    return true;
}

vector<vector<int>> concatenacion(vector<vector<int>>& A, vector<vector<int>>& B) {
    size_t maxFilas = max(A.size(), B.size());
    size_t colsA = A.empty() ? 0 : A[0].size();
    size_t colsB = B.empty() ? 0 : B[0].size();

    vector<vector<int>> resultado;

    for (size_t i = 0; i < maxFilas; ++i) {
        vector<int> fila;

        if (i < A.size()) fila.insert(fila.end(), A[i].begin(), A[i].end());
        else fila.insert(fila.end(), colsA, 0);

        if (i < B.size()) fila.insert(fila.end(), B[i].begin(), B[i].end());
        else fila.insert(fila.end(), colsB, 0);

        resultado.push_back(fila);
    }

    return resultado;
}

vector<vector<int>> fusionCombinatoria(vector<vector<int>>& BM, vector<vector<int>>& Testores) {
    vector<vector<int>> resultado;

    for (const auto& filaBM : BM) {
        for (const auto& filaTestores : Testores) {
            vector<int> filaNueva;
            filaNueva.insert(filaNueva.end(), filaBM.begin(), filaBM.end());
            filaNueva.insert(filaNueva.end(), filaTestores.begin(), filaTestores.end());
            resultado.push_back(filaNueva);
        }
    }
    return resultado;
}

vector<vector<int>> operadorDiagonal(vector<vector<int>>& A, vector<vector<int>>& B) {
    int filasA = A.size();
    int colsA = (filasA > 0) ? A[0].size() : 0; 
    int filasB = B.size();
    int colsB = (filasB > 0) ? B[0].size() : 0;

    vector<vector<int>> resultado(filasA + filasB, vector<int>(colsA + colsB, 0));

    for (int i = 0; i < filasA; i++) {
        for (int j = 0; j < colsA; j++) {
            resultado[i][j] = A[i][j];
        }
    }

    for (int i = 0; i < filasB; i++) {
        for (int j = 0; j < colsB; j++) {
            resultado[i + filasA][j + colsA] = B[i][j];
        }
    }

    return resultado;
}

void imprimirMatriz(const vector<vector<int>>& matriz, const string& nombre) {
    cout << "\n--- Resultado de " << nombre << " ---\n";
    if (matriz.empty() || (matriz.size() > 0 && matriz[0].empty())) {
        cout << "Matriz vacia.\n";
        return;
    }
    for (const auto& fila : matriz) {
        for (const auto& elemento : fila) {
            cout << elemento << " ";
        }
        cout << endl;
    }
}

int main() {
    vector<vector<int>> BM;
    vector<vector<int>> Testores;

    const string archivoBM = "matriz.txt";
    const string archivoTestores = "matriz_B.txt";
    const string archivoSalida = "operadores.txt";

    ofstream limpiar(archivoSalida); limpiar.close();

    cout << "Leyendo archivos..." << endl;
    if (!leerMatrizUnica(archivoBM, BM)) return 1;
    if (!leerMatrizUnica(archivoTestores, Testores)) return 1;

    vector<vector<int>> baseFusion = fusionCombinatoria(BM, Testores);
    escribirEnArchivo(baseFusion, "Base: Fusion Combinatoria (Potencia 1)", archivoSalida);
    cout << "Fusion Combinatoria base calculada." << endl;

    //  Concatenar siempre con la matriz original BM
    vector<vector<int>> gammaActual = baseFusion;
    for (int k = 2; k <= 5; k++) {
        gammaActual = concatenacion(gammaActual, BM);  // ← CAMBIO AQUÍ
        string titulo = "(Concatenacion) Potencia " + to_string(k);
        escribirEnArchivo(gammaActual, titulo, archivoSalida);
    }
    cout << "Operaciones de concatenacion completadas." << endl;

    // Diagonal con baseFusion (no se cambia salvo que lo pidas)
    vector<vector<int>> phiActual = baseFusion;
    for (int k = 2; k <= 5; k++) {
        phiActual = operadorDiagonal(phiActual, baseFusion);
        string titulo = "Diagonal Potencia " + to_string(k);
        escribirEnArchivo(phiActual, titulo, archivoSalida);
    }

    cout << "Operaciones Diagonal completadas." << endl;
    cout << "Todos los resultados guardados en: " << archivoSalida << endl;

    return 0;
}

